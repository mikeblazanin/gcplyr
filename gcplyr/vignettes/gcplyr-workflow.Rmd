---
title: "gcplyr-workflow"
author: "Mike Blazanin"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{gcplyr-workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction
`gcplyr` is a package that implements a number of functions to make it
easier to import, manipulate, and analyze growth curve data generated by
a spectrophotometer.

# Overview and philosophy
There are three primary layouts that growth curves-related data can be in: block-shaped, wide-shaped, and tidy-shaped. `gcplyr` can read in all three different layouts of data, and then transform them into tidy-shaped data for subsequent analyses.

* block-shaped: block-shaped data has a shape which corresponds literally to the physical dimensions of a multi-well plate. In block-shaped data, a data point from the first row and first column of the file/dataframe corresponds to the topmost and leftmost well in the physical plate. A time-series of block-shaped data will have many separate block-shaped files/dataframes, with each file/dataframe corresponding to a single timepoint.
* wide-shaped: in wide-shaped data, each column of the file/dataframe corresponds to a single well from the plate, and each row of the file/dataframe corresponds to a single timepoint. Information on which well corresponds to which column is contained in the column names/header of the dataframe/file.
* tidy-shaped: in tidy-shaped data, each unique measurement-well-timepoint combination has a row, with columns containing the information on the spectrophotometric measure, design elements, and timepoint. Please see Wickham, Hadley. Tidy data. The Journal of Statistical Software, vol. 59, 2014. for more details.

Additionally, there are broadly two classes of growth curves-related information to be manipulated: numerical spectrophotometric data, and experimental design elements. If reading from files, `gcplyr` can read both classes of information, transform them, and merge them for subsequent analyses. `gcplyr` also contains the capability of specifying design elements programmatically, which can then be merged with imported spectrophotometric data.

Once spectrophotometric data and design elements have been combined, this merged measures-designs tidy-shaped dataframe can be used for subsequent pre-processing and analyses.

![General overview of gcplyr workflow](pkg-workflow.png){#id .class width=7in height=2.45in}

Note that `gcplyr` can handle multiple plates throughout this process, using lists which contain the corresponding single-plate data.frames as elements. Once design elements have been merged with these data.frames so that independent plates can be distinguished, multiple-plate lists can be collapsed together into a single tidy-shaped measures-designs dataframe using `merge_dfs`.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(gcplyr)
```

# Importing data
One of the first tasks of any growth curves analysis project is to import the data into the R environment. `gcplyr` contains a number of functions to handle data import, depending on how your data is formatted. Broadly speaking, importing data uses the `read_\*` functions.

## Importing block-shaped data
To import block-shaped data, use the `read_blocks` function. `read_blocks` needs only a list of filenames (or file paths relative to the current working directory), and returns a dataframe (if only one file is specified) or list of dataframes (if multiple files are specified, where each dataframe corresponds to a single file). 

```{r}
#Example code to be written here
```

Note that `read_blocks` has a number of arguments to specify further details about the arrangement of your data, like the rows and columns where your data resides in the input files. If these arguments are not specified, `read_blocks` will attempt to infer the correct location of the data within the file.

## Importing wide-shaped data
To import wide-shaped data, use the `read_wides` function. `read_wides` needs only a list of filenames (or file paths relative to the current working directory), and returns a dataframe (if only one file is specified) or a list of dataframes (if multiple files are specified, where each dataframe corresponds to a single file).

```{r}
#Let's save an example file
temp_filename <- paste(tempfile(), ".csv", sep = "")
write.csv(example_widedata, file = temp_filename, row.names = FALSE)

#Now let's use read_wides to import our wide-shaped data
imported_widedata <- read_wides(files = temp_filename)

#If we had multiple wide-shaped data files to import
imported_widedata <- read_wides(files = c(temp_filename, temp_filename))
```

Note that `read_wides` has a number of arguments to specify further details about the arrangement of your data, like the rows and columns where your data resides in the input files. If these arguments are not specified, `read_wides` will attempt to infer the correct location of the data within the file.

```{r}
#Let's save an example file where the data doesn't start right away
temp_filename <- paste(tempfile(), ".csv", sep = "")
temp_example_widedata <- example_widedata
colnames(temp_example_widedata) <- paste("V", 1:ncol(temp_example_widedata),
                                         sep = "")
modified_example_widedata <-
  rbind(
    as.data.frame(matrix("", nrow = 4, ncol = ncol(example_widedata))),
    colnames(example_widedata),
    temp_example_widedata)
modified_example_widedata[1:2, 1:2] <- 
  c("Experiment name", "Start date", "Experiment_1", as.character(Sys.Date()))

write.csv(modified_example_widedata, file = temp_filename, 
          row.names = FALSE)

#Let's take a peek at what this file looks like
head(read.csv(temp_filename), c(10, 4), row.names = FALSE)

#Now let's use read_wides to import our wide-shaped data
imported_widedata <- read_wides(files = temp_filename,
                                startrow = 7, header = TRUE)
```

Additionally, `read_wides` has the option to specify additional metadata located in the input files that will be added to the resulting dataframes. For instance, a common piece of metadata is the date and time the file was generated, or an experiment name generated by the spectrophotometer. Each piece of metadata can be specified with a vector containing the row and column where the metadata is located in the input file.

```{r}
#We'll use the same example file as the previous chunk, but this time
# specifying the metadata included in the first two rows of the file
imported_widedata <- read_wides(files = temp_filename,
                                startrow = 7, header = TRUE,
                                metadata = list("experiment_name" = c(2, 2),
                                                "start_date" = c(3, 2)))
```

# Transforming data
Once data have been read into the R environment, `gcplyr` handles transformation of data that is block-shaped or wide-shaped using the `trans_\*` functions.

## Transforming from block-shaped to wide-shaped

To transform block-shaped data into wide-shaped data, use `trans_block_to_wide`. 
```{r}
#Example code to be written here
```

## Transforming from wide-shaped to tidy-shaped

To transform wide-shaped data into tidy-shaped data, use `trans_wide_to_tidy`.

```{r}
#Example code to be written here
```

# Including design elements
Often during analysis of growth curves data, we'd like to incorporate information on the experimental design. For example, which bacteria are present in which wells, or which wells have received some treatment (whether it be changes in growth media, antibiotics, phage presence, etc). `gcplyr` enables incorporation of design elements in two ways:
1. Design elements can be imported from files using `read_\*` functions
2. Design elements can be generated programmatically using `make_tidydesign`

## Reading design elements from files
Just like spectrophotometric data, design elements that are saved in tabular data files can be read using the `read_\*` functions. Simply use `read_blocks` or `read_wides` to read such files into the R environment.

Then, just as for spectrophotometric data, use the `trans_\*` functions to transform this data into tidy-shaped.

## Generating tidy-shaped design elements programmatically
`gcplyr` also has the ability to generate tidy-shaped design dataframes from arguments via `make_tidydesign`. `make_tidydesign` allows generation of dataframes with multiple design elements, each of which can have multiple values.

`make_tidydesign` is written so that design elements can be specified according to their spatial location in the multiwell plate. The resulting dataframe, however, is already tidy-shaped, so that users do not have to transform the resulting design elements dataframe.

### An example
For example, let's imagine a growth curves experiment where a 96 well plate (12 columns and 8 rows) has a different media in each column in the plate, but the first and last columns and first and last rows were left empty.

Row names | Column 1 | Column 2 | Column 3 | ... | Column 11 | Column 12
--------- | -------- | -------- | -------- | --- | --------- | --------
Row A     | Blank    | Blank    | Blank    | ... | Blank     | Blank
Row B     | Blank    | Media #1 | Media #2 | ... | Media #10 | Blank
...       |...       | ...      | ...      | ... | ...       | ... 
Row G     | Blank    | Media #1 | Media #2 | ... | Media #10 | Blank
Row H     | Blank    | Blank    | Blank    | ... | Blank     | Blank

To generate a tidy-shaped design dataframe representing this information, we can use `make_tidydesign`. 
Each design element has the following structure
'name_of_design_element' = list(
* a vector containing the possible values
* a vector containing all the rows these values should be applied to
* a vector containing all the columns these values should be applied to
* a string of the pattern itself within those rows and columns
* an optional Boolean for whether this pattern should be filled byrow (defaults to TRUE)
)

```{r}
my_design <- make_tidydesign(
  nrows = 8, ncols = 12, lookup_tbl_start = "a",
  Media = list(c("Media 1", "Media 2", "Media 3",
                 "Media 4", "Media 5", "Media 6",
                 "Media 7", "Media 8", "Media 9",
                 "Media 10", "Media 11", "Media 12"),
               2:7,
               2:11,
               "abcdefghij"))
head(my_design, 20)
```

### A few notes on the pattern string
In order to fill in the values, make_tidydesign uses `strsplit` to split the pattern string with the split character specified by `pattern_split`.

If this splitting results in pattern items that are more than 1 character long, all pattern items must be numeric.

If this splitting results in pattern items that are all only 1 character long, the items can be alpha numeric. Items will be indexed against a lookup table that has the following order: first, the numbers, starting with 1 and proceeding up to 9, then, capitalized letters, starting with A and proceeding up to Z, then, lowercase letters, starting with a and proceeding up to z.

Note that you can mix numbers, capitalized letters, and lowercase letters, but a warning will be issued if the utilized items are not consecutive in the lookup table.

0 is a reserved character for `NA` values to be filled in.

### Continuing with the example
Returning to the previous example, now let's imagine in the same experiment we also loaded a different bacterial strain into each row of the plate. 

Row names | Column 1 | Column 2  | Column 3  | ... | Column 11 | Column 12
--------- | -------- | --------  | --------  | --- | --------- | --------
Row A     | Blank    | Blank     | Blank     | ... | Blank     | Blank
Row B     | Blank    | Strain #1 | Strain #1 | ... | Strain #1 | Blank
Row B     | Blank    | Strain #2 | Strain #2 | ... | Strain #2 | Blank
...       |...       | ...       | ...       | ... | ...       | ... 
Row G     | Blank    | Strain #5 | Strain #5 | ... | Strain #5 | Blank
Row G     | Blank    | Strain #6 | Strain #6 | ... | Strain #6 | Blank
Row H     | Blank    | Blank     | Blank     | ... | Blank     | Blank

We can generate that design by adding an additional argument to our make_tidydesign call.

```{r}
my_design <- make_tidydesign(
  nrows = 8, ncols = 12, lookup_tbl_start = "a",
  Media = list(c("Media 1", "Media 2", "Media 3",
                 "Media 4", "Media 5", "Media 6",
                 "Media 7", "Media 8", "Media 9",
                 "Media 10", "Media 11", "Media 12"),
               2:7,
               2:11,
               "abcdefghij"),
  Bacteria = list(c("Strain 1", "Strain 2", "Strain 3",
                    "Strain 4", "Strain 5", "Strain 6"),
                  2:7,
                  2:11,
                  "abcdef",
                  FALSE))
head(my_design, 20)
```

Finally, let's imagine that we later discover that Bacterial Strain 4 and Media #6 were contaminated, and we'd like to exclude them from our analyses by marking them as `NA` in the design. We can simply modify our pattern string, placing a 0 anywhere we would like an `NA` to be filled in.

```{r}
my_design <- make_tidydesign(
  nrows = 8, ncols = 12, lookup_tbl_start = "a",
  Media = list(c("Media 1", "Media 2", "Media 3",
                 "Media 4", "Media 5", "Media 6",
                 "Media 7", "Media 8", "Media 9",
                 "Media 10", "Media 11", "Media 12"),
               2:7,
               2:11,
               "abcde0ghij"),
  Bacteria = list(c("Strain 1", "Strain 2", "Strain 3",
                    "Strain 4", "Strain 5", "Strain 6"),
                  2:7,
                  2:11,
                  "abc0ef",
                  FALSE))
head(my_design, 20)
```

Note that `make_tidydesign` is not limited to simple alternating patterns. The pattern string specified can be any pattern, which `make_tidydesign` will replicate sufficient times to cover the entire set of listed wells.

```{r}
my_design <- make_tidydesign(
  nrows = 8, ncols = 12, lookup_tbl_start = "a",
  Media = list(c("Media 1", "Media 2", "Media 3"),
               2:7,
               2:11,
               "aabbbc000abc"),
  Bacteria = list(c("Strain 1", "Strain 2"),
                  2:7,
                  2:11,
                  "abaaabbbab",
                  FALSE))
head(my_design, 20)
```

`gcplyr` also includes a helper function, `make_designpattern`, which simply facilitates the specification of the design elements by formatting them into a list and reminding users of the essential components that must be provided. For example, the following code produces the exact same design output as the earlier example:

```{r}
my_design <- make_tidydesign(
  nrows = 8, ncols = 12, lookup_tbl_start = "a",
  Media = make_designpattern(
    values = c("Media 1", "Media 2", "Media 3",
               "Media 4", "Media 5", "Media 6",
               "Media 7", "Media 8", "Media 9",
               "Media 10", "Media 11", "Media 12"),
    rows = 2:7, cols = 2:11, pattern = "abcde0ghij"),
  Bacteria = make_designpattern(
    values = c("Strain 1", "Strain 2", "Strain 3",
               "Strain 4", "Strain 5", "Strain 6"),
    rows = 2:7, cols = 2:11, pattern = "abc0ef",
    FALSE))
head(my_design, 20)
```



# Merging spectrophotometric and design data
Design and spectrophotometric data can be combined using `merge_dfs`, from which point they can be pre-processed and analyzed using additional functions.

# Pre-processing data

# Analyzing data