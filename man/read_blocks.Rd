% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{read_blocks}
\alias{read_blocks}
\title{Read blockmeasures}
\usage{
read_blocks(
  files,
  extension = NULL,
  startrow = NULL,
  endrow = NULL,
  startcol = NULL,
  endcol = NULL,
  sheet = NULL,
  metadata = NULL,
  block_names = NULL,
  header = NA,
  sider = NA,
  wellnames_Excel = TRUE,
  ...
)
}
\arguments{
\item{files}{A vector of filepaths relative to the current working directory
where each filepath is a single plate read}

\item{extension}{(optional) the extension of the files:
"csv", "xls", or "xlsx", or "tbl" for use of read.table

If none provided, \code{read_blocks} will infer file extension from
provided filenames. When extension is not "csv", "xls", or
"xlsx" will use \code{utils::read.table}}

\item{startrow, endrow, startcol, endcol}{(optional) the rows and columns where 
the measures data are in \code{files},
can be a vector or list the same length as \code{files}, or
a single value that applies to all \code{files}.
If not provided data is presumed to begin on the first
row and column of the files.}

\item{sheet}{(optional) If data is in .xls or .xlsx files, which sheet it 
is located on. Defaults to the first sheet if not specified}

\item{metadata}{(optional) non-spectrophotometric data that should be associated
with each read blockmeasures. A list where each item in the
list is a vector of length 2. Each vector should provide the
row and column where the metadata is located in the blockmeasures
input file. If the list is named those names will be inherited
to the output metadata.}

\item{block_names}{(optional) vector of names corresponding to each plate
in \code{files}. If not provided, block_names are inferred
from the filenames}

\item{header}{\code{TRUE}, \code{FALSE}, or \code{NA}, or a vector of
such values, indicating whether the file(s) contains the
column names as its first line. If \code{header = NA}
will attempt to infer the presence of column names. If
\code{header = FALSE} or no column names are inferred when 
\code{header = NA}, column names will be generated
automatically according to \code{wellnames_Excel}}

\item{sider}{\code{TRUE}, \code{FALSE}, or \code{NA}, or a vector of
such values, indicating whether the file(s) contains the
row names as its first line. If \code{sider = NA}
will attempt to infer the presence of row names. If
\code{sider = FALSE} or no row names are inferred when 
\code{sider = NA}, row names will be generated
automatically according to \code{wellnames_Excel}}

\item{wellnames_Excel}{If row names and column names are not provided in the
input dataframe as specified by \code{header}
and \code{sider}, then names will be generated
automatically.
If \code{wellnames_Excel} is TRUE, generated names
will use Excel-style base-26 lettering for columns
and numbers for rows. 
If \code{wellnames_Excel} is FALSE, rows and columns
will be numbered with "R" and "C" prefixes, respectively.}

\item{...}{Other arguments passed to \code{utils::read.csv},
\code{readxl::read_xls}, \code{readxl::read_xlsx},
or \code{utils::read.table}}
}
\value{
A list where each entry is a list containing the block data frame
        followed by the block_names (or filenames, if block_names is not 
        provided) and any specified metadata.
}
\description{
A function that reads block measures into the R environment
}
\details{
For metadata, \code{read_blocks} can handle an arbitrary number of additional
 pieces of information to extract from each blockcurve file as metadata.
 These pieces of information are specified as a list of (named) vectors
 where each vector is the c(row, column) where the information is to be
 pulled from in the input files.

 This metadata is returned as the second list element of each
 blockcurve, e.g.:
 
  [[1]] [1] "data" #1 [2] "metadata"  [2][1] name #1
  
  [2][2] date-time #1
  
  [2][3] temp #1
  
  [[2]] [1] "data" #2 [2] "metadata"  [2][1] name #2
  
  [2][2] date-time #2
  
  [2][3] temp #2
  
  ...

 Calling \code{uninterleave} on the output of read_blocks works on block data
 and the associated metadata because uninterleave operates on the highest 
 level entries of the list (the [[1]] [[2]] level items), 
 leaving the meta-data associated with the block data

 \code{trans_block_to_wide} integrates this metadata into the
 wide-shaped dataframe it produces
}
