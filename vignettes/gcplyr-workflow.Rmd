---
title: "gcplyr-workflow"
author: "Mike Blazanin"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{gcplyr-workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Table of Contents
1. Introduction
2. Overview
3. Importing data
    + Block-shaped data
    + Wide-shaped data
4. Transforming data
    + Transforming from block-shaped to wide-shaped
    + Transforming from wide-shaped to tidy-shaped
5. Including design elements
    + Reading design elements from files
    + Creating design elements programmatically
6. Merging measures and designs
7. Pre-processing data
8. Analyzing data

# Introduction
`gcplyr` is a package that implements a number of functions to make it
easier to import, manipulate, and analyze bacterial growth curves data. This vignette serves as the main walkthrough of how to use `gcplyr`'s most common functions.

# Getting started
So you want to use `gcplyr` to analyze some growth curves data. What do you need? Most simply, all you need is the data file with the growth curves measures in it. This has to be saved in a tabular format (.csv, .xls, or .xlsx).

Additionally, it's often best to combine your measures data with some information on the experimental design of your growth curves plate. For instance, information on which strains went into which wells. You can save this information into a tabular file as well, or you can just keep it handy to enter it directly through a function later on.

## Data layouts
Before we dive into actually using `gcplyr`, we need to establish a background on how `gcplyr` approaches different ways growth curves data can be organized. Generally, when dealing with both growth curves measures and design files, there are three common layouts that these files are organized in: block-shaped, wide-shaped, and tidy-shaped.

Unfortunately, while tidy-shaped is the ideal layout for analyses, it is not common for plate readers to output data in tidy-shaped layouts. Instead, most plate readers output data in block-shaped or wide-shaped format. Similarly, users will typically write design information in a block-shaped format. Thus, `gcplyr` has a number of functions to transform from block-shaped and wide-shaped layouts into tidy-shaped layouts for downstream analyses.

### Block-shaped

In block-shaped data, the organization of the data corresponds literally to the layout of the physical multi-well plate it was generated from. For instance, a data point from the first row and first column of the dataframe will be from the topmost and leftmost well in the physical plate. Because of this, a timeseries of growth curve data that is block-shaped will consist of many separate block-shaped dataframes, each corresponding to a single timepoint.

For example, here is a block-shaped dataframe of a 96-well plate. All the data here is from a single timepoint.

|         | Column 1 | Column 2  | Column 3  | ... | Column 11 | Column 12
--------- | -------- | --------  | --------  | --- | --------- | --------
**Row A** | 0.060    | 0.083     | 0.086     | ... | 0.082     | 0.085
**Row B** | 0.099    |0.069      |0.065      | ... |0.066      |0.078
**Row C** | 0.081    |0.071      |0.070      | ... |0.064      |0.084
**Row D** | 0.094    |0.075      |0.065      | ... |0.067      |0.087
**Row E** | 0.052    |0.054      |0.072      | ... |0.079      |0.065
**Row F** | 0.087    |0.095      |0.091      | ... |0.075      |0.058
**Row G** | 0.095    |0.079      |0.099      | ... |0.063      |0.075
**Row H** | 0.056    |0.069      |0.070      | ... |0.053      |0.078


### Wide-shaped

In wide-shaped data, each column of the dataframe corresponds to a single well from the plate, and each row of the dataframe corresponds to a single timepoint. Typically, headers contain the well names.

For example, here is a wide-shaped dataframe of a 96-well plate. Each row of this dataframe corresponds to a single timepoint.

Time      | A1 | A2 | A3  | ... | H11 | H12
--------- | -------- | --------  | --------  | --- | --------- | --------
0 | 0.060    | 0.083     | 0.086     | ... | 0.053     | 0.078
1 | 0.012    |0.166      |0.172      | ... |0.106      |0.156
2 | 0.024    |0.332      |0.344      | ... |0.212      |0.312
3 | 0.048    |0.664      |0.688      | ... |0.424      |0.624
4 | 0.096    |1.128      |0.976      | ... |0.848      |1.148
5 | 0.162    |1.256      |1.152      | ... |1.096      |1.296
6 | 0.181    |1.292      |1.204      | ... |1.192      |1.352
7 | 0.197    |1.324      |1.288      | ... |1.234      |1.394

### Tidy-shaped

In tidy-shaped data, each unique measurement has its own row, such that the number of rows equals the number of wells times the number of timepoints. In tidy-shaped data, additional columns specify the timepoint, well information, and any other design elements. Tidy-shaped data is the best format for downstream analyses, see: Wickham, Hadley. Tidy data. The Journal of Statistical Software, vol. 59, 2014. for more details.


Timepoint | Well | Measurement | 
--------- | -------- | ------- | 
1         | A1       | 0.060   | 
1         | A2       | 0.083   | 
1         | A3       | 0.086   | 
...       |...       | ...     |
7         | H10      | 1.113   | 
7         | H11      | 1.234   | 
7         | H12      | 1.394   | 







Additionally, there are broadly two classes of growth curves-related information to be manipulated: numerical spectrophotometric data, and experimental design elements. If reading from files, `gcplyr` can read both classes of information, transform them, and merge them for subsequent analyses. `gcplyr` also contains the capability of specifying design elements programmatically, which can then be merged with imported spectrophotometric data.

Once spectrophotometric data and design elements have been combined, this merged measures-designs tidy-shaped dataframe can be used for subsequent pre-processing and analyses.

![General overview of gcplyr workflow](pkg-workflow.png){#id .class width=7in height=2.45in}

Note that `gcplyr` can handle multiple plates throughout this process, using lists which contain the corresponding single-plate data.frames as elements. Once design elements have been merged with these data.frames so that independent plates can be distinguished, multiple-plate lists can be collapsed together into a single tidy-shaped measures-designs dataframe using `merge_dfs`.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(gcplyr)
```

# Importing data
One of the first tasks of any growth curves analysis project is to import the data into the R environment. `gcplyr` contains a number of functions to handle data import, depending on how your data is formatted. Broadly speaking, importing data uses the `read_\*` functions.

## Importing block-shaped data
To import block-shaped data, use the `read_blocks` function. `read_blocks` needs only a list of filenames (or file paths relative to the current working directory), and returns a dataframe (if only one file is specified) or list of dataframes (if multiple files are specified, where each dataframe corresponds to a single file). 

```{r}
#Let's create a set of example files
temp_filenames <- tempfile(pattern = as.character(example_widedata$Time),
                           fileext = ".csv")
for (i in 1:length(temp_filenames)) {
  write.table(
    cbind(matrix(c("", "", "A", "B", "C", "D", "E", "F", "G", "H"), nrow = 10),
          rbind(
            matrix(c("Time", example_widedata$Time[i], rep("", 10)), ncol = 12),
            matrix(1:12, ncol = 12),
            matrix(example_widedata[i, 2:ncol(example_widedata)], ncol = 12))), 
    file = temp_filenames[i], quote = FALSE, row.names = FALSE, sep = ",")
}

#Here's what one of the files looks like
print(read.csv(temp_filenames[1]))

#Now let's read it with read_blocks
imported_blockdata <- read_blocks(
  files = temp_filenames,
  startrow = 4, startcol = "B", endrow = 11, endcol = "M")
```

Note that `read_blocks` has a number of arguments to specify further details about the arrangement of your data, like the rows and columns where your data resides in the input files. If these arguments are not specified, `read_blocks` will attempt to infer the correct location of the data within the file.

Additionally, it is often necessary to specify metadata located in the input files. For block-shaped data, this typically includes at least the date-time when the data was gathered, but could also include other information generated by the spectrophotometer. In our example data, the time information is located in the 2nd row and 3rd column of the .csv file.

```{r}
#Reading the blockcurves files with metadata included
imported_blockdata <- read_blocks(
  files = temp_filenames,
  startrow = 4, startcol = "B", endrow = 11, endcol = "M",
  metadata = list("time" = c(2, 3)))
```


## Importing wide-shaped data
To import wide-shaped data, use the `read_wides` function. `read_wides` needs only a list of filenames (or file paths relative to the current working directory), and returns a dataframe (if only one file is specified) or a list of dataframes (if multiple files are specified, where each dataframe corresponds to a single file).

```{r}
#Let's create an example file
temp_filename <- paste(tempfile(), ".csv", sep = "")
write.csv(example_widedata, file = temp_filename, row.names = FALSE)

#Now let's use read_wides to import our wide-shaped data
imported_widedata <- read_wides(files = temp_filename)

#If we had multiple wide-shaped data files to import
imported_widedata <- read_wides(files = c(temp_filename, temp_filename))
```

Note that `read_wides` has a number of arguments to specify further details about the arrangement of your data, like the rows and columns where your data resides in the input files. If these arguments are not specified, `read_wides` will attempt to infer the correct location of the data within the file.

```{r}
#Let's save an example file where the data doesn't start right away
temp_filename <- tempfile(fileext = ".csv")
temp_example_widedata <- example_widedata
colnames(temp_example_widedata) <- paste("V", 1:ncol(temp_example_widedata),
                                         sep = "")
modified_example_widedata <-
  rbind(
    as.data.frame(matrix("", nrow = 4, ncol = ncol(example_widedata))),
    colnames(example_widedata),
    temp_example_widedata)
modified_example_widedata[1:2, 1:2] <- 
  c("Experiment name", "Start date", "Experiment_1", as.character(Sys.Date()))

write.csv(modified_example_widedata, file = temp_filename, 
          row.names = FALSE)

#Let's take a peek at what this file looks like
head(read.csv(temp_filename), c(10, 4), row.names = FALSE)

#Now let's use read_wides to import our wide-shaped data
imported_widedata <- read_wides(files = temp_filename,
                                startrow = 7, header = TRUE)
```

Additionally, `read_wides` has the option to specify additional metadata located in the input files that will be added to the resulting dataframes. For instance, a common piece of metadata is the date and time the file was generated, or an experiment name generated by the spectrophotometer. Each piece of metadata can be specified with a vector containing the row and column where the metadata is located in the input file.

```{r}
#We'll use the same example file as the previous chunk, but this time
# specifying the metadata included in the first two rows of the file
imported_widedata <- read_wides(files = temp_filename,
                                startrow = 7, header = TRUE,
                                metadata = list("experiment_name" = c(2, 2),
                                                "start_date" = c(3, 2)))
```

# Transforming data
Once data have been read into the R environment, `gcplyr` handles transformation of data that is block-shaped or wide-shaped using the `trans_\*` functions.

## Transforming from block-shaped to wide-shaped

To transform block-shaped data into wide-shaped data, use `trans_block_to_wide`. 
```{r}
#Example code to be written here
```

## Transforming from wide-shaped to tidy-shaped

To transform wide-shaped data into tidy-shaped data, use `trans_wide_to_tidy`.

```{r}
#Example code to be written here
```

# Including design elements
Often during analysis of growth curves data, we'd like to incorporate information on the experimental design. For example, which bacteria are present in which wells, or which wells have received some treatment (whether it be changes in growth media, antibiotics, phage presence, etc). `gcplyr` enables incorporation of design elements in two ways:
1. Design elements can be imported from files using `read_\*` functions
2. Design elements can be generated programmatically using `make_tidydesign`

## Reading design elements from files
Just like spectrophotometric data, design elements that are saved in tabular data files can be read using the `read_\*` functions. Simply use `read_blocks` or `read_wides` to read such files into the R environment.

Then, just as for spectrophotometric data, use the `trans_\*` functions to transform this data into tidy-shaped.

## Generating tidy-shaped design elements programmatically
`gcplyr` also has the ability to generate tidy-shaped design dataframes from arguments via `make_tidydesign`. `make_tidydesign` allows generation of dataframes with multiple design elements, each of which can have multiple values.

`make_tidydesign` is written so that design elements can be specified according to their spatial location in the multiwell plate. The resulting dataframe, however, is already tidy-shaped, so that users do not have to transform the resulting design elements dataframe.

### An example
For example, let's imagine a growth curves experiment where a 96 well plate (12 columns and 8 rows) has a different media in each column in the plate, but the first and last columns and first and last rows were left empty.

Row names | Column 1 | Column 2 | Column 3 | ... | Column 11 | Column 12
--------- | -------- | -------- | -------- | --- | --------- | --------
Row A     | Blank    | Blank    | Blank    | ... | Blank     | Blank
Row B     | Blank    | Media #1 | Media #2 | ... | Media #10 | Blank
...       |...       | ...      | ...      | ... | ...       | ... 
Row G     | Blank    | Media #1 | Media #2 | ... | Media #10 | Blank
Row H     | Blank    | Blank    | Blank    | ... | Blank     | Blank

To generate a tidy-shaped design dataframe representing this information, we can use `make_tidydesign`. 
Each design element has the following structure
'name_of_design_element' = list(
* a vector containing the possible values
* a vector containing all the rows these values should be applied to
* a vector containing all the columns these values should be applied to
* a string of the pattern itself within those rows and columns
* an optional Boolean for whether this pattern should be filled byrow (defaults to TRUE)
)

```{r}
my_design <- make_tidydesign(
  nrows = 8, ncols = 12, lookup_tbl_start = "a",
  Media = list(c("Media 1", "Media 2", "Media 3",
                 "Media 4", "Media 5", "Media 6",
                 "Media 7", "Media 8", "Media 9",
                 "Media 10", "Media 11", "Media 12"),
               2:7,
               2:11,
               "abcdefghij"))
head(my_design, 20)
```

### A few notes on the pattern string
In order to fill in the values, make_tidydesign uses `strsplit` to split the pattern string with the split character specified by `pattern_split`.

If this splitting results in pattern items that are more than 1 character long, all pattern items must be numeric.

If this splitting results in pattern items that are all only 1 character long, the items can be alpha numeric. Items will be indexed against a lookup table that has the following order: first, the numbers, starting with 1 and proceeding up to 9, then, capitalized letters, starting with A and proceeding up to Z, then, lowercase letters, starting with a and proceeding up to z.

Note that you can mix numbers, capitalized letters, and lowercase letters, but a warning will be issued if the utilized items are not consecutive in the lookup table.

0 is a reserved character for `NA` values to be filled in.

### Continuing with the example
Returning to the previous example, now let's imagine in the same experiment we also loaded a different bacterial strain into each row of the plate. 

Row names | Column 1 | Column 2  | Column 3  | ... | Column 11 | Column 12
--------- | -------- | --------  | --------  | --- | --------- | --------
Row A     | Blank    | Blank     | Blank     | ... | Blank     | Blank
Row B     | Blank    | Strain #1 | Strain #1 | ... | Strain #1 | Blank
Row B     | Blank    | Strain #2 | Strain #2 | ... | Strain #2 | Blank
...       |...       | ...       | ...       | ... | ...       | ... 
Row G     | Blank    | Strain #5 | Strain #5 | ... | Strain #5 | Blank
Row G     | Blank    | Strain #6 | Strain #6 | ... | Strain #6 | Blank
Row H     | Blank    | Blank     | Blank     | ... | Blank     | Blank

We can generate that design by adding an additional argument to our make_tidydesign call.

```{r}
my_design <- make_tidydesign(
  nrows = 8, ncols = 12, lookup_tbl_start = "a",
  Media = list(c("Media 1", "Media 2", "Media 3",
                 "Media 4", "Media 5", "Media 6",
                 "Media 7", "Media 8", "Media 9",
                 "Media 10", "Media 11", "Media 12"),
               2:7,
               2:11,
               "abcdefghij"),
  Bacteria = list(c("Strain 1", "Strain 2", "Strain 3",
                    "Strain 4", "Strain 5", "Strain 6"),
                  2:7,
                  2:11,
                  "abcdef",
                  FALSE))
head(my_design, 20)
```

Finally, let's imagine that we later discover that Bacterial Strain 4 and Media #6 were contaminated, and we'd like to exclude them from our analyses by marking them as `NA` in the design. We can simply modify our pattern string, placing a 0 anywhere we would like an `NA` to be filled in.

```{r}
my_design <- make_tidydesign(
  nrows = 8, ncols = 12, lookup_tbl_start = "a",
  Media = list(c("Media 1", "Media 2", "Media 3",
                 "Media 4", "Media 5", "Media 6",
                 "Media 7", "Media 8", "Media 9",
                 "Media 10", "Media 11", "Media 12"),
               2:7,
               2:11,
               "abcde0ghij"),
  Bacteria = list(c("Strain 1", "Strain 2", "Strain 3",
                    "Strain 4", "Strain 5", "Strain 6"),
                  2:7,
                  2:11,
                  "abc0ef",
                  FALSE))
head(my_design, 20)
```

Note that `make_tidydesign` is not limited to simple alternating patterns. The pattern string specified can be any pattern, which `make_tidydesign` will replicate sufficient times to cover the entire set of listed wells.

```{r}
my_design <- make_tidydesign(
  nrows = 8, ncols = 12, lookup_tbl_start = "a",
  Media = list(c("Media 1", "Media 2", "Media 3"),
               2:7,
               2:11,
               "aabbbc000abc"),
  Bacteria = list(c("Strain 1", "Strain 2"),
                  2:7,
                  2:11,
                  "abaaabbbab",
                  FALSE))
head(my_design, 20)
```

`gcplyr` also includes a helper function, `make_designpattern`, which simply facilitates the specification of the design elements by formatting them into a list and reminding users of the essential components that must be provided. For example, the following code produces the exact same design output as the earlier example:

```{r}
my_design <- make_tidydesign(
  nrows = 8, ncols = 12, lookup_tbl_start = "a",
  Media = make_designpattern(
    values = c("Media 1", "Media 2", "Media 3",
               "Media 4", "Media 5", "Media 6",
               "Media 7", "Media 8", "Media 9",
               "Media 10", "Media 11", "Media 12"),
    rows = 2:7, cols = 2:11, pattern = "abcde0ghij"),
  Bacteria = make_designpattern(
    values = c("Strain 1", "Strain 2", "Strain 3",
               "Strain 4", "Strain 5", "Strain 6"),
    rows = 2:7, cols = 2:11, pattern = "abc0ef",
    FALSE))
head(my_design, 20)
```



# Merging spectrophotometric and design data
Design and spectrophotometric data can be combined using `merge_dfs`, from which point they can be pre-processed and analyzed using additional functions.

# Pre-processing data

# Analyzing data